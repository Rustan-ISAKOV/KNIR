package com.company; // Это пакет, название проекта в обратном порядке. В данном пакете хранятся все те классы, с
// которыми мы работаем, их структура и связи.

// Область видимости - это то, как компилятор видит некие переменные

//import java.lang.String;    // для импортирования переменных String
import java.util.Scanner;

public class Main {
    // поле (переменная).
    int x=0;

    //--------------------------------------------------------
    // Перегрузка методов (функций)
    public static int summ (int a, int b) {
        return a + b;
    }
    public static int summ (int a, int b, int c) {
        return a + b + c;
    }

    public static float summ (float a, float b, float c) {
        return a + b + c;
    }
    // Перегрузка методов (функций)


    // метод main, void - ничего не возвращает
    public static void main (String[] args) {
        // здесь поле x не будет видно в данном методе. Т.к. она за гранью видимости данного метода
        // чтобы было видно н. записать this.x - т.е. это поле данного класса и ищет ее вне данного метода main
        // поля, объявленные внутри метода, в классе данного метода не видны
        // т.е. поля видны там где они создаются

        // Перегрузка методов (функций)
        //summ(12, 23) - вызывает именно тот метод (функцию) из вышеуказанных, которая подходит по  запрашиваемым
        // параметрам  и их типам
        System.out.println(summ(12, 23));
        System.out.println(summ(12, 23, 55));
        System.out.println(summ(12.5f, 23.26f, 55.12f));

//--------------------------------------------------------
        // объект или экземпляр класса
        Person vasya = new Person(140); // сработал конструктор с передачей параметра
        System.out.println("vasya.height = " + vasya.height);

        // объект или экземпляр класса
        Person petya = new Person(); // здесь сработал конструктор по умолчанию, height - по умолчанию
        System.out.println("petya.height = " + petya.height);
        petya.say("Garik!");

        // объект или экземпляр класса
        Person kolya = new Person(100); // сработал конструктор с передачей параметра
        System.out.println("kolya.height = " + kolya.height);

        // объект или экземпляр класса
        Person sanya = new Person(250, "Sanya"); // сработал конструктор с передачей 2 параметров
        System.out.println("Рост Сани = " + sanya.height);

        // объект или экземпляр класса
        Person dima = new Person("Dima"); // сработал конструктор с передачей 1 параметра, height - по умолчанию
        System.out.println("Рост Димы = " + dima.height + ". Имя Димы: " + dima.name);
        System.out.println("-------------------------");

        // объект или экземпляр класса Student
/*        Student freshman  = new Student(); // создание объекта
        System.out.println("Name: " + freshman.name);
        System.out.println("Course: " + freshman.course);*/

        // создаем объект freshman ? указали три значения и вызываем метод tell
        Student freshman  = new Student(55, "Alena", 2); // создание объекта
        freshman.tell(); // вызов конструктора

        Student freshman2  = new Student(155, "Tema", 3); // создание объекта
        freshman2.tell(); // вызов конструктора

        // полиморфизм. для этого создали 4 объекта, 3 из них Circle, Square, Triangle наследуют у 1 го Shape
        // массив из объектов и ему присваиваем значения
        Shape [] arr = new Shape [] {new Circle(), new Square(), new Triangle()};
        for (int i=0; i<arr.length; i++)
            arr[i].draw ();

        // т.о. что получается, у нас есть один простой метод draw в основном классе и есть дополнительно 3 draw
        // метода в классах наследниках. И при вызове этого одного метода для каждого класса, он переопределяется для
        // каждого объекта.


//--------------------------------------------------------
// Анонимные классы и вложенные классы

        // вложенные классы - 1 класс, и внутри этого класса есть еще один класс.
        // Т.е. Создаем файл Computer.java, в него помещаем класс Computer, и в этот класс помещаем еще один класс
        // Processor и RAM.
        // для

        //Создаем новый объект comp класса Computer
        Computer comp = new Computer();
        //Теперь, обращаемся к методу start() объекта i7 подкласса Processor, который
        // вложен в класс Computer объекта comp класса Computer, т.е. объекта i7 подкласса Processor, вложенного в
        // класс Computer
        //
/*        comp.i7.start();
        comp.transfer.start();
        comp.transfer.shutdown();
        comp.i7.shutdown();*/

//--------------------------------------------------------
// Анонимные классы
        // используется если тело класса очень короткое или в нем ничего нету
        // если нужен только один экземпляр класса
        // если класс используется в месте создания или после него
        // если имя класса не важно и не облегчает понимание кода

        // Пример анонимного класса,  у него нет ни имени, ничего
/*        new Computer() {
            // 1 метод
            void superComp () {
                this.i7.start();
                this.transfer.start();
            }
        };*/
//--------------------------------------------------------
// Абстрактные классы - одна из концепций  ООП.
        // на основе А.к. нельзя создавать объекты
        // чтобы создавать абстрактные методы, то и сам класс должен быть абстрактным

/*        Abstract AbsCircle = new AbsCircle();
        AbsCircle.draw();*/

















    }
}